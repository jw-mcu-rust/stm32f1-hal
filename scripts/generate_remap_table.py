import csv
import os
import pprint
import subprocess
from io import TextIOWrapper

DRY_RUN = False
SCRIPT = os.path.relpath(__file__, os.getcwd()).replace("\\", "/")
REMAP_MODES = {
    "DEFAULT": "RemapDefault",
    "PARTIAL_REMAP": "RemapPart1",
    "PARTIAL_REMAP1": "RemapPart1",
    "PARTIAL_REMAP2": "RemapPart2",
    "FULL_REMAP": "RemapFull",
    "REMAP": "RemapFull",
}


class Write:
    def __init__(self, file_name: str) -> None:
        if DRY_RUN:
            self.f = None
        else:
            self.f = open(file_name, "w", encoding="utf-8")

    def write(self, content: str) -> None:
        if self.f:
            self.f.write(content)
        else:
            print(content, end="")

    def close(self) -> None:
        if self.f:
            self.f.close()
            self.f = None


def match_filter(filter: str, name: str) -> bool:
    if filter == "UART":
        return name.startswith("UART") or name.startswith("USART")
    return name.startswith(filter)


UART_IMPL_TEMPLATE_DICT = {
    "TX": "impl UartTxPin<{dev}> for {pin}<Alternate<PushPull>> {{",
    "RX": "impl<PULL: UpMode> UartRxPin<{dev}> for {pin}<Input<PULL>> {{",
}
UART_TEMPLATE = """
    type RemapMode = {mode}<{dev}>;
}}
"""


def write_uart_item(dev: str, mode: str, pins: list[str], w: Write) -> None:
    for pin in pins:
        (pin_func, pin) = pin.split(":")
        impl = UART_IMPL_TEMPLATE_DICT.get(pin_func, "")
        if impl:
            w.write(impl.format(dev=dev, pin=pin))
            w.write(UART_TEMPLATE.format(mode=mode, dev=dev))


def write_binder_type(d: dict, filter: str, w: Write) -> None:
    w.write("\n// Binder types ------------------\n\n")
    func_list: list[str] = []
    for dev, remap_modes in d.items():
        if match_filter(filter, dev):
            for pins in remap_modes.values():
                for pin in pins:
                    (pin_func, _) = pin.split(":")
                    func_list.append(pin_func)

    func_list = sorted(list(set(func_list)))
    for func in func_list:
        name = filter[0] + filter[1:].lower() + func[0] + func[1:].lower()
        w.write(f"pub trait {name}Pin<PERI> {{type RemapMode;}}")
    w.write("\n")


def write_table(d: dict, filter: str, csv_file: str, target_file: str) -> None:
    with open(target_file, "r", encoding="utf-8") as f:
        code = f.read()
        i = code.find("// table") + len("// table")
        before = code[:i]
        code = code[i:]

    w = Write(target_file)
    w.write(before)
    w.write("\n// Do NOT manually modify the code.\n")
    w.write(
        f"// It's generated by {SCRIPT} from {csv_file}\n",
    )
    write_binder_type(d, filter, w)
    w.write("\n// Bind Pins ---------------------\n\n")
    for dev, remap_modes in sorted(d.items()):
        for mode, pins in sorted(remap_modes.items()):
            mode = REMAP_MODES[mode]
            if match_filter(filter, dev):
                write_uart_item(dev, mode, pins, w)
    w.close()
    subprocess.run(["rustfmt", target_file])


def parse_remap_info(row: list[str], ret_d: dict) -> None:
    d_list = []
    for d in row[2:]:
        if d:
            d_list.append(d)

    dma = ret_d.setdefault(row[0], {})
    dma[row[1]] = d_list


def csv_to_code(csv_file: str, show: bool = False) -> None:
    print(csv_file)
    d: dict = {}
    with open(csv_file, newline="", encoding="utf-8") as f:
        reader = csv.reader(f, delimiter=",", quotechar='"')
        for row in reader:
            if row[0]:
                parse_remap_info(row, d)

    if show:
        pprint.pprint(d)

    write_table(d, "UART", csv_file, "src/afio/uart_remap.rs")
    # write_menu(d, csv_file, prefix, menu_file)
    # write_table(d, csv_file, prefix, table_file)


if __name__ == "__main__":
    csv_to_code("scripts/table/stm32f1_remap_device.csv")
