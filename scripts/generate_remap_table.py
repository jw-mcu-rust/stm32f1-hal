import csv
import os
import pprint
import subprocess
from io import TextIOWrapper

DRY_RUN = False
SCRIPT = os.path.relpath(__file__, os.getcwd()).replace("\\", "/")
REMAP_MODES = {
    "DEFAULT": "RemapDefault",
    "PARTIAL_REMAP": "RemapPart1",
    "PARTIAL_REMAP1": "RemapPart1",
    "PARTIAL_REMAP2": "RemapPart2",
    "FULL_REMAP": "RemapFull",
    "REMAP": "RemapFull",
}


class Write:
    def __init__(self, file_name: str) -> None:
        if DRY_RUN:
            self.f = None
        else:
            self.f = open(file_name, "w", encoding="utf-8")

    def write(self, content: str) -> None:
        if self.f:
            self.f.write(content)
        else:
            print(content, end="")

    def close(self) -> None:
        if self.f:
            self.f.close()
            self.f = None


def match_filter(filter: str, name: str) -> bool:
    if filter == "UART":
        return name.startswith("UART") or name.startswith("USART")
    return name.startswith(filter)


REG_TEMPLATE = """impl RemapMode for {mode}<{peri}> {{
    fn remap(afio: &mut Afio) {{
        {op}
    }}
}}
"""


def write_reg_operation(d: dict, filter: str, w: Write) -> None:
    w.write("\n// Register operation ------------\n\n")
    for peri, remap_modes in sorted(d.items()):
        if match_filter(filter, peri):
            for mode_name, mode_info in sorted(remap_modes.items()):
                mode = REMAP_MODES[mode_name]
                reg = mode_info["reg"]
                bits: str = mode_info["bits"]
                if reg == "none":
                    op = ""
                elif len(bits) == 3:
                    b = "set_bit" if bits[2] == "1" else "clear_bit"
                    op = f"afio.{reg}.modify_mapr(|_, w| w.{peri.lower()}_remap().{b}());"
                elif len(bits) == 4:
                    b = f"unsafe {{|_, w| w.{peri.lower()}_remap().bits({bits})}}"
                    op = f"afio.{reg}.modify_mapr({b});"
                else:
                    continue
                w.write(REG_TEMPLATE.format(mode=mode, peri=peri, op=op))


def write_binder_type(d: dict, filter: str, w: Write) -> None:
    w.write("\n// Binder types ------------------\n\n")
    func_list: list[str] = []
    for peri, remap_modes in d.items():
        if match_filter(filter, peri):
            for mode_info in remap_modes.values():
                for pin_func in mode_info["pins"].keys():
                    func_list.append(pin_func)

    func_list = sorted(list(set(func_list)))
    for func in func_list:
        name = filter[0] + filter[1:].lower() + func[0] + func[1:].lower()
        w.write(f"pub trait {name}Pin<PERI> {{type RemapMode;}}")
    w.write("\n")


UART_IMPL_TEMPLATE_DICT = {
    "TX": "impl UartTxPin<{peri}> for {pin}<Alternate<PushPull>> {{",
    "RX": "impl<PULL: UpMode> UartRxPin<{peri}> for {pin}<Input<PULL>> {{",
}
UART_TEMPLATE = """
    type RemapMode = {mode}<{peri}>;
}}
"""


def write_uart_item(peri: str, mode: str, pins: dict[str, str], w: Write) -> None:
    for pin_func, pin in sorted(pins.items()):
        impl = UART_IMPL_TEMPLATE_DICT.get(pin_func, "")
        if impl:
            w.write(impl.format(peri=peri, pin=pin))
            w.write(UART_TEMPLATE.format(mode=mode, peri=peri))


def write_table(d: dict, filter: str, csv_file: str, target_file: str) -> None:
    with open(target_file, "r", encoding="utf-8") as f:
        code = f.read()
        i = code.find("// table") + len("// table")
        before = code[:i]
        code = code[i:]

    w = Write(target_file)
    w.write(before)
    w.write("\n// Do NOT manually modify the code.\n")
    w.write(
        f"// It's generated by {SCRIPT} from {csv_file}\n",
    )
    write_reg_operation(d, filter, w)
    write_binder_type(d, filter, w)
    w.write("\n// Bind pins ---------------------\n\n")
    for peri, remap_modes in sorted(d.items()):
        if match_filter(filter, peri):
            for mode_name, mode_info in sorted(remap_modes.items()):
                mode = REMAP_MODES[mode_name]
                write_uart_item(peri, mode, mode_info["pins"], w)
    w.close()
    subprocess.run(["rustfmt", target_file])


def parse_remap_info(row: list[str], ret_d: dict) -> None:
    peripheral = row[0]
    reg = row[1]
    remap_mode = row[2]
    reg_bits = row[3]
    pins: dict[str, str] = {}
    for pin in row[4:]:
        if pin:
            (func, pin) = pin.split(":")
            pins[func] = pin

    p = ret_d.setdefault(peripheral, {})
    p[remap_mode] = {
        "reg": reg,
        "bits": reg_bits,
        "pins": pins,
    }


def csv_to_code(csv_file: str, show: bool = False) -> None:
    print(csv_file)
    d: dict = {}
    with open(csv_file, newline="", encoding="utf-8") as f:
        reader = csv.reader(f, delimiter=",", quotechar='"')
        for row in reader:
            if row[0]:
                parse_remap_info(row, d)

    if show:
        pprint.pprint(d)

    write_table(d, "UART", csv_file, "src/afio/uart_remap.rs")
    # write_menu(d, csv_file, prefix, menu_file)
    # write_table(d, csv_file, prefix, table_file)


if __name__ == "__main__":
    csv_to_code("scripts/table/stm32f1_remap_peripheral.csv")
